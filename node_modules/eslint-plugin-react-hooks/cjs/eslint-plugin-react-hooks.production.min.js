/** @license React vundefined
 * eslint-plugin-react-hooks.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';function M(a){if("Identifier"===a.type)return/^use[A-Z0-9].*$/.test(a.name);if("MemberExpression"===a.type&&!a.computed&&M(a.property)){a=a.object;var c=/^[A-Z].*/;return"Identifier"===a.type&&c.test(a.name)}return!1}function aa(a){return"Identifier"===a.type?!/^[a-z]/.test(a.name):!1}function ba(a,c){return a.name===c||"MemberExpression"===a.type&&"React"===a.object.name&&a.property.name===c}function ea(a){return!!(a.parent&&a.parent.callee&&ba(a.parent.callee,"forwardRef"))}
function fa(a){return!!(a.parent&&a.parent.callee&&ba(a.parent.callee,"memo"))}function ha(a){for(;a;){var c=ia(a);if(c&&(aa(c)||M(c))||ea(a)||fa(a))return!0;a=a.parent}return!1}
function ia(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:
a.parent.key}
function ja(a){function c(){return{isRequired:!1,isSatisfiedRecursively:!1,hasRequiredNodesBelow:!1,children:new Map}}function b(a,d){d=d.split(".");var k=!0,f=!1,h=void 0;try{for(var e=d[Symbol.iterator](),b;!(k=(b=e.next()).done);k=!0){var n=b.value,z=a.children.get(n);z||(z=c(),a.children.set(n,z));a=z}}catch(G){f=!0,h=G}finally{try{k||null==e.return||e.return()}finally{if(f)throw h;}}return a}function e(a,c,d){c=c.split(".");var k=!0,f=!1,h=void 0;try{for(var e=c[Symbol.iterator](),b;!(k=
(b=e.next()).done);k=!0){var z=a.children.get(b.value);if(!z)break;d(z);a=z}}catch(G){f=!0,h=G}finally{try{k||null==e.return||e.return()}finally{if(f)throw h;}}}function f(a,c,d,h){a.children.forEach(function(a,k){var e=h(k);a.isSatisfiedRecursively?a.hasRequiredNodesBelow&&d.add(e):a.isRequired?c.add(e):f(a,c,d,function(a){return e+"."+a})})}var C=a.dependencies,p=a.declaredDependencies,u=a.optionalDependencies,x=a.externalDependencies,y=a.isEffect,H=c();C.forEach(function(a,c){b(H,c).isRequired=
!0;e(H,c,function(a){a.hasRequiredNodesBelow=!0})});p.forEach(function(a){b(H,a.key).isSatisfiedRecursively=!0});u.forEach(function(a){b(H,a).isSatisfiedRecursively=!0});a=new Set;var h=new Set;f(H,a,h,function(a){return a});var d=[],z=new Set,A=new Set;p.forEach(function(a){a=a.key;h.has(a)?-1===d.indexOf(a)?d.push(a):A.add(a):!y||a.endsWith(".current")||x.has(a)?z.add(a):-1===d.indexOf(a)&&d.push(a)});a.forEach(function(a){d.push(a)});return{suggestedDependencies:d,unnecessaryDependencies:z,duplicateDependencies:A,
missingDependencies:a}}
function ka(a){var c=a.declaredDependenciesNode,b=a.componentScope,e=a.scope;return a.declaredDependencies.map(function(a){a=b.set.get(a.key);if(null==a)return null;var c=a.defs[0];return null==c?null:"Variable"===c.type&&"VariableDeclarator"===c.node.type&&null!=c.node.init&&("ArrowFunctionExpression"===c.node.init.type||"FunctionExpression"===c.node.init.type)||"FunctionName"===c.type&&"FunctionDeclaration"===c.node.type?a:null}).filter(Boolean).map(function(a){var b=a.defs[0];a:{for(var f=!1,u=
0;u<a.references.length;u++){var x=a.references[u];if(x.writeExpr)if(f){a=!0;break a}else{f=!0;continue}for(var y=x.from;y!==e&&null!=y;)y=y.upper;if(y!==e&&!la(c,x.identifier)){a=!0;break a}}a=!1}return{fn:b,suggestUseCallback:a}})}
function ma(a){return"MemberExpression"!==a.parent.type&&"OptionalMemberExpression"!==a.parent.type||a.parent.object!==a||"current"===a.parent.property.name||a.parent.computed||null!=a.parent.parent&&"CallExpression"===a.parent.parent.type&&a.parent.parent.callee===a.parent?"MemberExpression"===a.type&&a.parent&&"AssignmentExpression"===a.parent.type?a.object:a:ma(a.parent)}
function Y(a){if("Identifier"===a.type)return a.name;if("MemberExpression"!==a.type||a.computed){if("OptionalMemberExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);var c=Y(a.object);a=Y(a.property);return c+"?."+a}c=Y(a.object);a=Y(a.property);return c+"."+a}function na(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
function pa(a,c){var b=na(a);if("Identifier"!==b.type)return-1;switch(b.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(b===a&&c&&c.additionalHooks){try{var e=Y(b)}catch(f){if(/Unsupported node type/.test(f.message))return 0;throw f;}return c.additionalHooks.test(e)?0:-1}return-1}}
function qa(a,c){for(var b=[a],e=null;b.length;){e=b.shift();if("Identifier"===e.type&&e.name===c.name&&e.range[0]===c.range[0]&&e.range[1]===c.range[1])return e;if(la(e,c)){a=0;for(var f=Object.entries(e);a<f.length;a++){var C=f[a],p=C[1];"parent"!==C[0]&&(ra(p)?(p.parent=e,b.push(p)):Array.isArray(p)&&p.forEach(function(a){ra(a)&&(a.parent=e,b.push(a))}))}}}return null}
function sa(a){for(var c="",b=0;b<a.length;b++)c+=a[b],0===b&&2===a.length?c+=" and ":b===a.length-2&&2<a.length?c+=", and ":b<a.length-1&&(c+=", ");return c}function ra(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}function la(a,c){return a.range[0]<=c.range[0]&&a.range[1]>=c.range[1]}exports.configs={recommended:{plugins:["react-hooks"],rules:{"react-hooks/rules-of-hooks":"error","react-hooks/exhaustive-deps":"warn"}}};
exports.rules={"rules-of-hooks":{meta:{type:"problem",docs:{description:"enforces the Rules of Hooks",category:"Possible Errors",recommended:!0,url:"https://reactjs.org/docs/hooks-rules.html"}},create:function(a){var c=[],b=[];return{onCodePathSegmentStart:function(a){return b.push(a)},onCodePathSegmentEnd:function(){return b.pop()},onCodePathStart:function(){return c.push(new Map)},onCodePathEnd:function(e,b){function f(a,c){var b=f.cache,d=b.get(a.id);c=new Set(c);if(c.has(a.id)){b=[].concat(c);
a=b.slice(b.indexOf(a.id)+1);b=!0;d=!1;var g=void 0;try{for(var m=a[Symbol.iterator](),B;!(b=(B=m.next()).done);b=!0)y.add(B.value)}catch(I){d=!0,g=I}finally{try{b||null==m.return||m.return()}finally{if(d)throw g;}}return 0}c.add(a.id);if(void 0!==d)return d;if(e.thrownSegments.includes(a))d=0;else if(0===a.prevSegments.length)d=1;else{d=0;m=!0;B=!1;var K=void 0;try{g=a.prevSegments[Symbol.iterator]();for(var h;!(m=(h=g.next()).done);m=!0)d+=f(h.value,c)}catch(I){B=!0,K=I}finally{try{m||null==
g.return||g.return()}finally{if(B)throw K;}}}a.reachable&&0===d?b.delete(a.id):b.set(a.id,d);return d}function p(a,c){var d=p.cache,b=d.get(a.id);c=new Set(c);if(c.has(a.id)){d=Array.from(c);a=d.slice(d.indexOf(a.id)+1);d=!0;b=!1;var g=void 0;try{for(var m=a[Symbol.iterator](),B;!(d=(B=m.next()).done);d=!0)y.add(B.value)}catch(I){b=!0,g=I}finally{try{d||null==m.return||m.return()}finally{if(b)throw g;}}return 0}c.add(a.id);if(void 0!==b)return b;if(e.thrownSegments.includes(a))b=0;else if(0===
a.nextSegments.length)b=1;else{b=0;m=!0;B=!1;var K=void 0;try{g=a.nextSegments[Symbol.iterator]();for(var h;!(m=(h=g.next()).done);m=!0)b+=p(h.value,c)}catch(I){B=!0,K=I}finally{try{m||null==g.return||g.return()}finally{if(B)throw K;}}}d.set(a.id,b);return b}function u(a){var c=u.cache,b=c.get(a.id);if(null===b)return Infinity;if(void 0!==b)return b;c.set(a.id,null);if(0===a.prevSegments.length)b=1;else{b=Infinity;var d=!0,g=!1,m=void 0;try{for(var B=a.prevSegments[Symbol.iterator](),K;!(d=
(K=B.next()).done);d=!0){var h=u(K.value);h<b&&(b=h)}}catch(I){g=!0,m=I}finally{try{d||null==B.return||B.return()}finally{if(g)throw m;}}b+=1}c.set(a.id,b);return b}var x=c.pop();if(0!==x.size){var y=new Set;f.cache=new Map;p.cache=new Map;u.cache=new Map;var H=p(e.initialSegment),h=ia(b),d=ha(b),z=h?aa(h)||M(h):ea(b)||fa(b),A=Infinity,k=!0,n=!1,T=void 0;try{for(var q=e.finalSegments[Symbol.iterator](),U;!(k=(U=q.next()).done);k=!0){var D=U.value;if(D.reachable){var w=u(D);w<A&&(A=w)}}}catch(F){n=
!0,T=F}finally{try{k||null==q.return||q.return()}finally{if(n)throw T;}}k=!0;n=!1;T=void 0;try{for(var P=x[Symbol.iterator](),Z;!(k=(Z=P.next()).done);k=!0){var G=Z.value,t=G[0],W=G[1];if(t.reachable){var Q=0===t.nextSegments.length?A<=u(t):A<u(t),N=f(t)*p(t),L=y.has(t.id);x=!0;q=!1;U=void 0;try{for(var l=W[Symbol.iterator](),E;!(x=(E=l.next()).done);x=!0){var v=E.value;L&&a.report({node:v,message:'React Hook "'+a.getSource(v)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});
if(z){if(!L&&N!==H){var R='React Hook "'+a.getSource(v)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+(Q?" Did you accidentally call a React Hook after an early return?":"");a.report({node:v,message:R})}}else if(b.parent&&("MethodDefinition"===b.parent.type||"ClassProperty"===b.parent.type)&&b.parent.value===b){var S='React Hook "'+a.getSource(v)+'" cannot be called in a class component. React Hooks must be called in a React function component or a custom React Hook function.';
a.report({node:v,message:S})}else if(h){var J='React Hook "'+a.getSource(v)+'" is called in function "'+(a.getSource(h)+'" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter.');a.report({node:v,message:J})}else if("Program"===b.type){var X='React Hook "'+a.getSource(v)+'" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:v,message:X})}else if(d){var O=
'React Hook "'+a.getSource(v)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:v,message:O})}}}catch(F){q=!0,U=F}finally{try{x||null==l.return||l.return()}finally{if(q)throw U;}}}}}catch(F){n=!0,T=F}finally{try{k||null==P.return||P.return()}finally{if(n)throw T;}}}},CallExpression:function(a){if(M(a.callee)){var e=c[c.length-1],C=b[b.length-1],p=e.get(C);p||(p=[],e.set(C,p));p.push(a.callee)}}}}},"exhaustive-deps":{meta:{type:"suggestion",
docs:{description:"verifies the list of dependencies for Hooks like useEffect and similar",category:"Best Practices",recommended:!0,url:"https://github.com/facebook/react/issues/14920"},fixable:"code",schema:[{type:"object",additionalProperties:!1,enableDangerousAutofixThisMayCauseInfiniteLoops:!1,properties:{additionalHooks:{type:"string"},enableDangerousAutofixThisMayCauseInfiniteLoops:{type:"boolean"}}}]},create:function(a){function c(c){f&&Array.isArray(c.suggest)&&0<c.suggest.length&&(c.fix=
c.suggest[0].fix);a.report(c)}function b(a,c){return function(b){if(c.has(b))return c.get(b);var d=a(b);c.set(b,d);return d}}function e(h,d,e,f,k){function z(a){var c=!0,g=!1,b=void 0;try{for(var d=a.references[Symbol.iterator](),e;!(c=(e=d.next()).done);c=!0){var f=e.value;if(f.resolved&&C.has(f.resolved.scope)){var p=qa(h,f.identifier),l=ma(p),A=Y(l),q;if(q=k&&"Identifier"===l.type&&"MemberExpression"===l.parent.type&&!l.parent.computed&&"Identifier"===l.parent.property.type&&"current"===l.parent.property.name){for(var n=
f.from,u=!1;n.block!==h;)"function"===n.type&&(u=null!=n.block.parent&&"ReturnStatement"===n.block.parent.type),n=n.upper;q=u}q&&G.set(A,{reference:f,dependencyNode:l});var r=f.resolved.defs[0];if(null!=r&&(null==r.node||r.node.init!==h.parent)&&"TypeParameter"!==r.type)if(t.has(A))t.get(A).references.push(f);else{var w=f.resolved,x=P(w)||Z(w);t.set(A,{isStatic:x,references:[f]})}}}}catch(da){g=!0,b=da}finally{try{c||null==d.return||d.return()}finally{if(g)throw b;}}c=!0;g=!1;b=void 0;try{for(var v=
a.childScopes[Symbol.iterator](),y;!(c=(y=v.next()).done);c=!0)z(y.value)}catch(da){g=!0,b=da}finally{try{c||null==v.return||v.return()}finally{if(g)throw b;}}}function A(a,c,b,d){return 0===a.size?null:(1<a.size?"":c+" ")+b+" "+(1<a.size?"dependencies":"dependency")+": "+sa(Array.from(a).sort().map(function(a){return"'"+a+"'"}))+(". Either "+d+" "+(1<a.size?"them":"it")+" or remove the dependency array.")}k&&h.async&&c({node:h,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching"});
for(var q=p.acquire(h),C=new Set,D=null,w=q.upper;w;){C.add(w);if("function"===w.type)break;w=w.upper}if(w){D=w;var P=b(function(a){if(!Array.isArray(a.defs))return!1;var c=a.defs[0];if(null==c||"VariableDeclarator"!==c.node.type)return!1;var b=c.node.init;if(null==b)return!1;for(;"TSAsExpression"===b.type;)b=b.expression;var g=c.node.parent;if(null==g&&(qa(D.block,c.node.id),g=c.node.parent,null==g))return!1;if("const"===g.kind&&"Literal"===b.type&&("string"===typeof b.value||"number"===typeof b.value||
null===b.value))return!0;if("CallExpression"!==b.type)return!1;b=b.callee;"MemberExpression"!==b.type||"React"!==b.object.name||null==b.property||b.computed||(b=b.property);if("Identifier"!==b.type)return!1;c=c.node.id;b=b.name;if("useRef"===b&&"Identifier"===c.type)return!0;if(("useState"===b||"useReducer"===b)&&"ArrayPattern"===c.type&&2===c.elements.length&&Array.isArray(a.identifiers)){if(c.elements[1]===a.identifiers[0]){if("useState"===b)for(a=a.references,b=0;b<a.length;b++)u.set(a[b].identifier,
c.elements[0]);return!0}if(c.elements[0]===a.identifiers[0]&&"useState"===b)for(a=a.references,c=0;c<a.length;c++)x.add(a[c].identifier)}return!1},y),Z=b(function(a){if(!Array.isArray(a.defs))return!1;a=a.defs[0];if(null==a||null==a.node||null==a.node.id)return!1;var c=a.node,b=D.childScopes;a=null;var d;for(d=0;d<b.length;d++){var g=b[d],e=g.block;if("FunctionDeclaration"===c.type&&e===c||"VariableDeclarator"===c.type&&e.parent===c){a=g;break}}if(null==a)return!1;for(d=0;d<a.through.length;d++)if(c=
a.through[d],null!=c.resolved&&C.has(c.resolved.scope)&&!P(c.resolved))return!1;return!0},H),G=new Map,t=new Map;z(q);G.forEach(function(a,b){var d=a.dependencyNode;a=a.reference.resolved.references;for(var g=!1,e=0;e<a.length;e++){var m=a[e].identifier.parent;if(null!=m&&"MemberExpression"===m.type&&!m.computed&&"Identifier"===m.property.type&&"current"===m.property.name&&"AssignmentExpression"===m.parent.type&&m.parent.left===m){g=!0;break}}g||c({node:d.parent.property,message:"The ref value '"+
b+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '"+(b+".current' to a variable inside the effect, and use that variable in the cleanup function.")})});var W=new Set,Q=new Set;t.forEach(function(b,d){var g=b.references;b.isStatic&&Q.add(d);g.forEach(function(b){b.writeExpr&&(b=b.writeExpr,W.has(d)||(W.add(d),c({node:b,message:"Assignments to the '"+d+"' variable from inside React Hook "+(a.getSource(e)+" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside ")+
(a.getSource(e)+".")})))})});if(!(0<W.size))if(d){var N=[],L=new Set;"ArrayExpression"!==d.type?c({node:d,message:"React Hook "+a.getSource(e)+" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):d.elements.forEach(function(b){if(null!==b)if("SpreadElement"===b.type)c({node:b,message:"React Hook "+a.getSource(e)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});
else{try{var d=Y(b)}catch(oa){if(/Unsupported node type/.test(oa.message)){"Literal"===b.type?t.has(b.value)?c({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. Did you mean to include "+(b.value+" in the array instead?")}):c({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):c({node:b,message:"React Hook "+a.getSource(e)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});
return}throw oa;}for(var g=b;"MemberExpression"===g.type;)g=g.object;var h=!D.through.some(function(a){return a.identifier===g});N.push({key:d,node:b});h||L.add(d)}});var l=ja({dependencies:t,declaredDependencies:N,optionalDependencies:Q,externalDependencies:L,isEffect:k});w=l.unnecessaryDependencies;var E=l.missingDependencies,v=l.duplicateDependencies,R=l.suggestedDependencies;if(0===v.size+E.size+w.size)ka({declaredDependencies:N,declaredDependenciesNode:d,componentScope:D,scope:q}).forEach(function(a){var b=
a.fn;a=a.suggestUseCallback;var g="The '"+b.name.name+"' function makes the dependencies of "+(f+" Hook (at line "+d.loc.start.line+") change on every render.");g=a?g+(" To fix this, wrap the '"+(b.name.name+"' definition into its own useCallback() Hook.")):g+(" Move it inside the "+f+" callback. Alternatively, wrap the '"+(b.name.name+"' definition into its own useCallback() Hook."));var e;a&&"Variable"===b.type&&(e=[{desc:"Wrap the '"+b.name.name+"' definition into its own useCallback() Hook.",
fix:function(a){return[a.insertTextBefore(b.node.init,"useCallback("),a.insertTextAfter(b.node.init,")")]}}]);c({node:b.node,message:g,suggest:e})});else{!k&&0<E.size&&(R=ja({dependencies:t,declaredDependencies:[],optionalDependencies:Q,externalDependencies:L,isEffect:k}).suggestedDependencies);(function(){if(0===N.length)return!0;var a=N.map(function(a){return a.key}),b=a.slice().sort();return a.join(",")===b.join(",")})()&&R.sort();l="";if(0<w.size){var S=null;Array.from(w.keys()).forEach(function(a){null===
S&&a.endsWith(".current")&&(S=a)});if(null!==S)l=" Mutable values like '"+S+"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(0<L.size){var J=Array.from(L)[0];q.set.has(J)||(l=" Outer scope values like '"+J+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!l&&E.has("props")){q=t.get("props");if(null==q)return;q=q.references;if(!Array.isArray(q))return;J=!0;for(var X=0;X<q.length;X++){var O=qa(D.block,q[X].identifier);
if(!O){J=!1;break}O=O.parent;if(null==O){J=!1;break}if("MemberExpression"!==O.type){J=!1;break}}J&&(l=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the "+(f+" call and refer to those specific props inside ")+(a.getSource(e)+"."))}if(!l&&0<E.size){var F=null;E.forEach(function(a){if(!F){var b=D.set.get(a),c=t.get(a);if(c.references[0].resolved===b&&(b=b.defs[0],null!=b&&null!=b.name&&"Parameter"===b.type)){b=!1;for(var d,
e=0;e<c.references.length;e++)if(d=c.references[e].identifier,null!=d&&null!=d.parent&&"CallExpression"===d.parent.type&&d.parent.callee===d){b=!0;break}b&&(F=a)}}});null!==F&&(l=" If '"+F+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!l&&0<E.size){var r=null;E.forEach(function(a){if(null===r)for(var b=t.get(a).references,c,d,e=0;e<b.length;e++){c=b[e].identifier;for(d=c.parent;null!=d&&d!==D.block;){if("CallExpression"===d.type){var g=
u.get(d.callee);if(null!=g){g.name===a?r={missingDep:a,setter:d.callee.name,form:"updater"}:x.has(c)?r={missingDep:a,setter:d.callee.name,form:"reducer"}:(c=b[e].resolved,null!=c&&(c=c.defs[0],null!=c&&"Parameter"===c.type&&(r={missingDep:a,setter:d.callee.name,form:"inlineReducer"})));break}}d=d.parent}if(null!==r)break}});if(null!==r)switch(r.form){case "reducer":l=" You can also replace multiple useState variables with useReducer if '"+(r.setter+"' needs the current value of '")+(r.missingDep+
"'.");break;case "inlineReducer":l=" If '"+r.setter+"' needs the current value of '"+(r.missingDep+"', you can also switch to useReducer instead of useState and read '")+(r.missingDep+"' in the reducer.");break;case "updater":l=" You can also do a functional update '"+r.setter+"("+r.missingDep.substring(0,1)+" => ...)' if you only need '"+r.missingDep+"' in the '"+(r.setter+"' call.");break;default:throw Error("Unknown case.");}}c({node:d,message:"React Hook "+a.getSource(e)+" has "+(A(E,"a","missing",
"include")||A(w,"an","unnecessary","exclude")||A(v,"a","duplicate","omit"))+l,suggest:[{desc:"Update the dependencies array to be: ["+R.join(", ")+"]",fix:function(a){return a.replaceText(d,"["+R.join(", ")+"]")}}]})}}else{var V=null;t.forEach(function(a,b){V||a.references.forEach(function(a){if(!V&&u.has(a.identifier)){for(a=a.from;"function"!==a.type;)a=a.upper;a.block===h&&(V=b)}})});if(V){var ca=ja({dependencies:t,declaredDependencies:[],optionalDependencies:Q,externalDependencies:new Set,isEffect:!0}).suggestedDependencies;
c({node:e,message:"React Hook "+f+" contains a call to '"+V+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+ca.join(", ")+("] as a second argument to the "+f+" Hook."),suggest:[{desc:"Add dependencies array: ["+ca.join(", ")+"]",fix:function(a){return a.insertTextAfter(h,", ["+ca.join(", ")+"]")}}]})}}}}var f=a.options&&a.options[0]&&a.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops||!1,C={additionalHooks:a.options&&a.options[0]&&
a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0,enableDangerousAutofixThisMayCauseInfiniteLoops:f},p=a.getSourceCode().scopeManager,u=new WeakMap,x=new WeakSet,y=new WeakMap,H=new WeakMap;return{CallExpression:function(b){var d=pa(b.callee,C);if(-1!==d){var f=b.arguments[d],h=b.callee,k=na(h).name,n=b.arguments[d+1];b=/Effect($|[^a-z])/g.test(k);if(n||b){switch(f.type){case "FunctionExpression":case "ArrowFunctionExpression":e(f,n,h,k,b);return;case "Identifier":if(!n||
n.elements&&n.elements.some(function(a){return"Identifier"===a.type&&a.name===f.name}))return;d=a.getScope().set.get(f.name);if(null==d||null==d.defs)return;d=d.defs[0];if(!d||!d.node)break;if("Variable"!==d.type&&"FunctionName"!==d.type)break;switch(d.node.type){case "FunctionDeclaration":e(d.node,n,h,k,b);return;case "VariableDeclarator":if(d=d.node.init)switch(d.type){case "ArrowFunctionExpression":case "FunctionExpression":e(d,n,h,k,b);return}}break;default:c({node:h,message:"React Hook "+k+" received a function whose dependencies are unknown. Pass an inline function instead."});
return}c({node:h,message:"React Hook "+k+" has a missing dependency: '"+f.name+"'. Either include it or remove the dependency array.",suggest:[{desc:"Update the dependencies array to be: ["+f.name+"]",fix:function(a){return a.replaceText(n,"["+f.name+"]")}}]})}else"useMemo"!==k&&"useCallback"!==k||c({node:h,message:"React Hook "+k+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"})}}}}}};
